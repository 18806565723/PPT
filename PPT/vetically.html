<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>葡萄藤PPT</title>
    <style>
        #box {
            float: left;
            width: 300px;
            height: 300px;
            background: #ddd;
            position: relative;
        }
        .right{
            float: left;
        }
        #child {
            width: 150px;
            height: 100px;
            background: orange;
            position: absolute;
            top: 50%;
            margin: -50px 0 0 0;
            line-height: 100px;
        }
        #box1 {
            width: 300px;
            height: 300px;
            background: #ddd;
            position: relative;
        }
        #child1 {
            background: #93BC49;
            position: absolute;
            top: 50%;
            transform: translate(0, -50%);
        }
        #box2 {
            width: 300px;
            height: 300px;
            background: #ddd;
            position: relative;
        }
        #child2 {
            width: 50%;
            height: 30%;
            background: pink;
            position: absolute;
            top: 50%;
            margin: -15% 0 0 0;
        }
        #box3 {
            width: 300px;
            height: 300px;
            background: #ddd;
            position: relative;
        }
        #child3 {
            width: 200px;
            height: 100px;
            background: #A1CCFE;
            position: absolute;
            top: 0;
            bottom: 0;
            margin: auto;
            line-height: 100px;
        }
        #box4 {
            width: 300px;
            background: #ddd;
            padding: 100px 0;
        }
        #child4 {
            width: 200px;
            height: 100px;
            background: #F7A750;
            line-height: 50px;
        }
        #box5 {
            width: 300px;
            height: 300px;
            background: #ddd;
        }
        #base {
            height: 50%;
            background: #AF9BD3;
        }
        #child5 {
            height: 100px;
            background: rgba(131, 224, 245, 0.6);
            line-height: 50px;
            margin-top: -50px;
        }
        #box6 {
            width: 300px;
            height: 300px;
            background: #ddd;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }
        #child6 {
            width: 300px;
            height: 100px;
            background: #08BC67;
            line-height: 100px;
        }
    </style>

    <link rel="stylesheet" href="../css/reveal/reveal.css">

    <!-- PPT主题，可以在/css/reveal/theme/中选择其他主题，目前暂时只能使用该模板 -->
    <link rel="stylesheet" href="../css/reveal/theme/ptt.css">

    <!-- syntax highlighting 代码高亮主题 -->
    <link rel="stylesheet" href="../lib/reveal/css/zenburn.css">

    <!-- 打印和PDF输出样式 -->
    <script>
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match( /print-pdf/gi ) ? '../css/reveal/print/pdf.css' : '../css/reveal/print/paper.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
</head>
<body>
<img src="../img/demo/logo.png" alt="" usemap="#pttmap" class="base-logo">
<map name="pttmap">
    <area shape="rect" coords="0,0,276,58" href="http://www.jnshu.com" alt="" target="_blank"/>
</map>
<div class="reveal">
    <div class="slides">
        <section>
            <h2>【CSS-task11】css有哪些方式可以实现垂直居中？</h2>
            <h3>小课堂【北京第23期】</h3>
            <p>分享人：汤金鑫</p>
        </section>
        <section>
            <p>目录</p>
            <p>1.背景介绍</p>
            <p>2.知识剖析</p>
            <p>3.常见问题</p>
            <p>4.编码实战</p>
            <p>5.扩展思考</p>
            <p>6.参考文献</p>
            <p>7.更多讨论</p>
        </section>
        <section>
            <h3>1.背景介绍</h3>
        </section>
        <section>
            <p>44年前我们把人送上月球，但在CSS中我们仍然不能很好的实现垂直居中。——@James Anderson一</p>
        </section>
        <section>
            <h3>2.知识剖析</h3>
        </section>
        <section>
            <h3>垂直居中就是竖向居中</h3>
        </section>
        <section>
            <h3>常见问题</h3>
        </section>
        <section>
        CSS 实现垂直居中并不容易。有些方法在一些浏览器中无效。下面我们看一下使对象垂直集中的N种不同方法，以及它们各自的优缺点。
            </section>
        <section>
            <h3>编码实战</h3>
        </section>
        <section>
            <div id="box">
                <div id="child">我是测试DIV</div>
            </div>
            <div class="right">
                1. 使用绝对定位和负外边距对块级元素进行垂直居中
                绝对定位实现垂直居中
                这个方法兼容性不错，但是有一个小缺点：必须提前知道被居中块级元素的尺寸，否则无法准确实现垂直居中。
            </div>
        </section>
        <section>
            <div id="box1">
                <div id="child1">
                    我是一串很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长的文本
                </div>
            </div>
            <div class="right">
                2. 使用绝对定位和transform
                这种方法有一个非常明显的好处就是不必提前知道被居中元素的尺寸了，因为transform中translate偏移的百分比就是相对于元素自身的尺寸而言的。
            </div>
        </section>
        <section>
            <div id="box2">
                <div id="child2">我也是个测试DIV</div>
            </div>
            <div class="right">
                3. 另外一种使用绝对定位和负外边距进行垂直居中的方式
                这种方式的原理实质上和前两种相同。补充的一点是：margin的取值也可以是百分比，这时这个值规定了该元素基于父元素尺寸的百分比，
                可以根据实际的使用场景来决定是用具体的数值还是用百分比。
            </div>
        </section>
        <section>
            <div id="box3">
                <div id="child3">呆呆</div>
            </div>
            <div class="right">
               4.绝对定位结合margin: auto
                这种实现方式的两个核心是：把要垂直居中的元素相对于父元素绝对定位，top和bottom设为相等的值，我这里设成了0
                ，当然你也可以设为99999px或者-99999px无论什么，只要两者相等就行，这一步做完之后再将要居中元素的margin设为auto，这样便可以实现垂直居中了。
                　　被居中元素的宽高也可以不设置，但不设置的话就必须是图片这种自身就包含尺寸的元素，否则无法实现
            </div>
        </section>
        <section>
            <div id="box4">
                <div id="child4">测试</div>
            </div>
            <div class="right">
                5. 使用padding实现子元素的垂直居中
                这种实现方式非常简单，就是给父元素设置相等的上下内边距，则子元素自然是垂直居中的，
                当然这时候父元素是不能设置高度的，要让它自动被填充起来，除非设置了一个正好等于上内
                边距+子元素高度+下内边距的值，否则无法精确的垂直居中。
                　　这种方式看似没有什么技术含量，但其实在某些场景下也是非常好用的
            </div>
        </section>
        <section>
            <div id="box5">
                <div id="base"></div>
                <div id="child5">测试！测试！测试！测试！测试！测试！测试！测试！</div>
            </div>
            <div class="right">
                6. 设置第三方基准
                这种方式也非常简单，首先设置一个高度等于父元素高度一半的第三方基准
                元素，那么此时该基准元素的底边线自然就是父元素纵向上的中分线，做完这些之后再给要垂直居中
                的元素设置一个margin-top，值的大小是它自身高度的一半取负，则实现垂直居中。
            </div>
        </section>
        <section>
            <div style=" width: 300px; height: 300px;background: #ddd; display: flex;align-items: center;">flex;align-items: center</div>
            </section>
        <section>
            <div style=" width: 300px;
    height: 300px;
    background: #ddd;
    display: flex;
    align-items: center;">
                <div style="  width: 300px;
    height: 100px;
    background: #8194AA;
    line-height: 100px; ">
                    测试
                </div>
            </div>
            <div class="right">
                7. 使用flex布局
                    flex布局（弹性布局/伸缩布局）里门道颇多，这里先针对用到的东西简单说一下，想深入学习的小伙伴可以去看阮一峰老师的博客。
                （http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html）
                　　flex也就是flexible，意为灵活的、柔韧的、易弯曲的。
                　　元素可以通过设置display:flex;将其指定为flex布局的容器，指定好了容器之后再为其添加align-items属性
                ，该属性定义项目在交叉轴（这里是纵向轴）上的对齐方式，可能的取值有五个，分别如下：
                　　flex-start:：交叉轴的起点对齐；
                　　flex-end：交叉轴的终点对齐；
                　　center：交叉轴的中点对齐；
                　　baseline：项目第一行文字的基线对齐；
                　　stretch（该值是默认值）：如果项目没有设置高度或者设为了auto，那么将占满整个容器的高度。
            </div>
        </section>
        <section>
            <div id="box6">
                <div id="child6">
                    测试
                </div>
            </div>
            <div class="right">
                8. 第二种使用弹性布局的方式
                这种方式也是首先给父元素设置display:flex，设置好之后改变主轴的方向flex-direction: column，该属性可能的取值有四个，分别如下：
                　　row（该值为默认值）：主轴为水平方向，起点在左端；
                　　row-reverse：主轴为水平方向，起点在右端；
                　　column：主轴为垂直方向，起点在上沿；
                　　column-reverse：主轴为垂直方向，起点在下沿。
                　　
                　　justify-content属性定义了项目在主轴上的对齐方式，可能的取值有五个，分别如下（不过具体的对齐方式与主轴的方向有关，以下的值都是假设主轴为从左到右的）：
                　　flex-start（该值是默认值）：左对齐；
                　　flex-end：右对齐；
                　　center：居中对齐；
                　　space-between：两端对齐，各个项目之间的间隔均相等；
                　　space-around：各个项目两侧的间隔相等。
            </div>
        </section>
        <section>
            <h3>扩展思考</h3>
        </section>
        <section>
            还有没有其他方式可以使其垂直居中，
            还有一种在前面已经见到过很多次的方式就是使用 line-height 对单行文本进行垂直居中
            使用 line-height 和 vertical-align 对图片进行垂直居中
            使用 display 和 vertical-align 对容器里的文字进行垂直居中
        </section>
        <section>
            <h3>6.参考文献</h3>
        </section>
        <section>
            <p>参考一：<a href="http://www.cnblogs.com/zhouhuan/p/vertical_center.html">垂直居中的实现方法</a></p>
        </section>
        <section>
            <h3>7.更多讨论</h3>
        </section>
        <section>
            <p>还有更多的方法吗？</p>
        </section>
        <section>
            <h4>鸣谢</h4>
            <p>感谢大家观看</p>
        </section>

    </div>
</div>

<script src="../lib/reveal/js/head.min.js"></script>
<script src="../lib/reveal/reveal.js"></script>

<script>
    // 以下为常见配置属性的默认值
    // {
    // 	controls: true, // 是否在右下角展示控制条
    // 	progress: true, // 是否显示演示的进度条
    // 	slideNumber: false, // 是否显示当前幻灯片的页数编号，也可以使用代码slideNumber: 'c / t' ，表示当前页/总页数。
    // 	history: false, // 是否将每个幻灯片改变加入到浏览器的历史记录中去
    // 	keyboard: true, // 是否启用键盘快捷键来导航
    // 	overview: true, // 是否启用幻灯片的概览模式，可使用"Esc"或"o"键来切换概览模式
    // 	center: true, // 是否将幻灯片垂直居中
    // 	touch: true, // 是否在触屏设备上启用触摸滑动切换
    // 	loop: false, // 是否循环演示
    // 	rtl: false, // 是否将演示的方向变成RTL，即从右往左
    // 	fragments: true, // 全局开启和关闭碎片。
    // 	autoSlide: 0, // 两个幻灯片之间自动切换的时间间隔（毫秒），当设置成 0 的时候则禁止自动切换，该值可以被幻灯片上的 ` data-autoslide` 属性覆盖
    // 	transition: 'default', // 切换过渡效果，有none/fade/slide/convex/concave/zoom
    // 	transitionSpeed: 'default', // 过渡速度，default/fast/slow
    // 	mouseWheel: true, //是否启用通过鼠标滚轮来切换幻灯片
    // }
    // 初始化幻灯片
    Reveal.initialize({
        history: true,
        dependencies: [
            { src: '../plugin/markdown/marked.js' },
            { src: '../plugin/markdown/markdown.js' },
            { src: '../plugin/notes/notes.js', async: true },
            { src: '../plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
        ]
    });
</script>
</body>
</html>
Contact GitHub API Training Shop Blog About
© 2016 GitHub, Inc. Terms Privacy Security Status He
